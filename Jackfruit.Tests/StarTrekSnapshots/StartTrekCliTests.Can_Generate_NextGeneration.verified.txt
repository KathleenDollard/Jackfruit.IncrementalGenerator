
using Jackfruit.Internal;

namespace Jackfruit
{
    /// <summary>
    /// This is the main class for the Jackfruit generator. After you call the 
    /// Create command, the returned RootCommand will contain your CLI. If you 
    /// need multiple root commands in your application differentiate them with &gt;T&lt;
    /// </summary>
    public partial class RootCommand : RootCommand<RootCommand, RootCommand.Result>
    {
        public new static RootCommand Create(CommandNode cliRoot)
            => (RootCommand)RootCommand<RootCommand, RootCommand.Result>.Create( cliRoot);
    }
}

// *******************************

// This file is created by a generator.
using DemoHandlers;

namespace Jackfruit
{
   public partial class RootCommand : RootCommand<RootCommand.Result>
   {
       static new RootCommand Create(CommandNode rootNode)
      {
         return RootCommand<RootCommand, RootCommand.Result>.Create("rootNode");
      }
      
   }
   
}

// *******************************

// This file is created by a generator.
using System;
using System.Threading.Tasks;
using System.CommandLine;
using System.CommandLine.Invocation;
using System.CommandLine.Parsing;
using Jackfruit.Internal;

namespace Jackfruit
{
    public partial class RootCommand : ICommandHandler
    {
      public RootCommand()
      {
            command.GreetingArgument = new Argument<string>("greetingArg");
            command.Add(command.GreetingArgument);
            command.PicardOption = new Option<bool>("--Picard");
            command.PicardOption.Description = "This is the description for Picard";
            command.PicardOption.AddAlias("-p");
            command.Add(command.PicardOption);
            command.AddValidator(command.Validate);
            command.Handler = command;
            return command;
        }

        /// <summary>
        /// The result class for the NextGeneration command.
        /// </summary>
        public class Result
        {
            string Greeting {get; set;}
            bool Picard {get; set;}
            /// <summary>
            /// Get an instance of the Result class for the NextGeneration command.
            /// </summary>
            /// <param name="command">The command corresponding to the result</param>
            /// <param name="invocationContext">The System.CommandLine InvocationContext used to retrieve.</param>
            internal static Result GetResult(NextGeneration command, InvocationContext invocationContext)
            {
                return new Result(command, invocationContext.ParseResult.CommandResult);
            }

            private protected Result(RootCommand command, CommandResult commandResult)
            {
                Greeting = GetValueForSymbol(command.GreetingArgument, commandResult);
                Picard = GetValueForSymbol(command.PicardOption, commandResult);
            }

            private protected Result(RootCommand command, InvocationContext invocationContext)
                : this(command, invocationContext.ParseResult.CommandResult)
            {
            }

        }

        /// <summary>
        /// The handler invoked by System.CommandLine. This will not be public when generated is more sophisticated.
        /// </summary>
        /// <param name="invocationContext">The System.CommandLine Invocation context used to retrieve values.</param>
        public int Invoke(InvocationContext invocationContext)
        {
            var result = Result.GetResult(this, invocationContext);
            DemoHandlers.Handlers.NextGeneration(result.Greeting, result.Picard);
            return invocationContext.ExitCode;
        }

        /// <summary>
        /// The handler invoked by System.CommandLine. This will not be public when generated is more sophisticated.
        /// </summary>
        /// <param name="invocationContext">The System.CommandLine Invocation context used to retrieve values.</param>
        public Task<int> InvokeAsync(InvocationContext invocationContext)
        {
            var result = Result.GetResult(this, invocationContext);
            DemoHandlers.Handlers.NextGeneration(result.Greeting, result.Picard);
            return Task.FromResult(invocationContext.ExitCode);
        }

        public Argument<string> GreetingArgument {get; set;}
        public Option<bool> PicardOption {get; set;}
    }

}
